package website.fanxian.dynamic_functional.regex;

import org.junit.Test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 常见正则表达式：
 *  邮编
 *  电话号码
 *  日期和时间
 *  身份证号
 *  IP地址
 *  URL
 *  Email地址
 *  中文字符
 * @author Kelvin范显
 * @createDate 2018年10月11日
 */
public class CommonRegex {

    @Test
    public void _1邮编(){
        String example = "邮编610000，电话18280202018";
        // 6位数字
        String regex = "[0-9]{6}"; // 610000 182802

        // 使用环视边界匹配， 对于左边界，它签名的字符不能是数字，环视表达式为：
            // (?<![0-9])
        // 对于右边界，它右边的字符不能使数字，环视表达式为：
            // (?![0-9])
        // 所以，完整的表达式可以为：
            // (?<![0-9])[0-9]{6}(?![0-9])
        String regex0 = "(?<![0-9])[0-9]{6}(?![0-9])"; // 610000
        Pattern p = Pattern.compile(regex0);
        Matcher matcher = p.matcher(example);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
    @Test
    public void _2手机号码(){
        String example = "手机号码 +8618280201234，不是手机号18280201234000";
        // 11位数字    [0-9]{11}
        // 第一位是1， 第2位取值3、4、5、7、8之一      1[34578][0-9]{9}
        // 为了方便表达手机号，可能会有（可能没有）连字符号(186-1234-5678)      1[34578][0-9]-?[0-9]{4}-?[0-9]{4}
        // 手机号前面可能会有： 0、+86或0086，和手机号码间可能还会有一个空格   ((0|\+86|0086)\s?)?1[34578][0-9]-?[0-9]{4}-?[0-9]{4}
        // 和邮编类似，还要加上环视边界   (?<![0-9])((0|\+86|0086)\s?)?1[34578][0-9]-?[0-9]{4}-?[0-9]{4}(?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])((0|\\+86|0086)\\s?)?1[34578][0-9]-?[0-9]{4}-?[0-9]{4}(?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }
    @Test
    public void _3固定电话号码(){
        String example = "固定电话010-62265678";
        // 区号（3或4位）和市内号码（7到8位）。 区号以0开头      0[0-9]{2,3}[0-9]{7,8}
        // 区号可能用括号包含，也肯用连字符号连接两部分，且区号是可选的：  (\(?0[0-9]{2,3}\)?-?)?[0-9]{7,8}
        // 再加上左右边界环视    (?<![0-9])(\(?0[0-9]{2,3}\)?-?)?[0-9]{7,8}(?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])(\\(?0[0-9]{2,3}\\)?-?)?[0-9]{7,8}(?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }

    @Test
    public void _4日期(){
        String example = "2018-09-20";
        // 月日可能只有一位     \d{4}-\d{1,2}-\d{1,3}
        // 月只能是1-12， 日只能是1-31
            // 1-9月： 0?[1-9]  10-12月：1[0-2]
            // 所以月表达式：(0?[1-9]|1[0-2])
        // 日的表达：
            // 1-9日     0?[1-9]
            // 10-29日   [1-2][0-9]
            // 30-31日   3[01]
            // 所以日表示式：(0?[1-9]|[1-2][0-9]|3[01])
        // 所以整个表达式： \d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[01])
        // 最后加上左右边界环视： (?<![0-9])\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[01])(?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])\\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[01])(?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }
    @Test
    public void _5时间(){
        String example = "10:57"; //24制
        // d{2}:\d{2}
        // 小时0-23    ([0-1][0-9]|2[0-3])
        // 分钟0-59     [0-5][0-9]
        // ([0-1][0-9]|2[0-3]):[0-5][0-9]
        // 左右边界环视       (?<![0-9])([0-1][0-9]|2[0-3]):[0-5][0-9](?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])([0-1][0-9]|2[0-3]):[0-5][0-9](?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }

    @Test
    public void _6身份证号(){
        String example = "52020119901106481X";
        // 1代身份证，15位不以0开头      [1-9][0-9]{14}
        // 2代身份证，18位不以0开头，最后一位可能是x或X      [1-9][0-9]{16}[0-9xX]
        // 合并       [1-9][0-9]{14}([0-9]{2}[0-9xX])?
        // 左右边界环视   (?<![0-9])[1-9][0-9]{14}([0-9]{2}[0-9xX])?(?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])[1-9][0-9]{14}([0-9]{2}[0-9xX])?(?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }

    @Test
    public void _7IP地址(){
        String example = "192.168.3.5";
        // (\d{1,3}\.){3}\d{1-3}
        // 0-255的约束 (0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])
        // ((0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}(0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])
        // 左右边界环视   (?<![0-9])((0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}(0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])(?![0-9])
        Pattern p = Pattern.compile("(?<![0-9])((0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(0{0,2}[0-9]|0?[0-9]{2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])(?![0-9])");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }
    @Test
    public void _8URL(){
        String example = "https://tools.ietf.org/html/rfc1738";
        // http://<host>:<port>/<path>?<searchpart>
        // 主机名 中字符可以是 字母、数字、减号和点号        [-0-9a-zA-Z.]+
        // 端口    (:\d+)?
        // 路径由多个子路径组成，每个子路径以/开头， 后跟0或多个非/的字符      (/[^/]*)*
            // 准确地，把所有允许的字符列出来    (/[-\w$.+!*'(),%;:@&=]*)*
        // 查询字符串，简单说，由非空字符串组成     \?[\S]*
            // 准确地      \?[-\w$.+!*'(),%;:@&=]*
        // 模式 (/<sub_path>(/<sub_path>)*(\?<search>)?)?
            // 简单   (/[^/]*(/[^/]*)*(\?[\S]*)?)?
            // 准确地  (/[-\w$.+!*'(),%;:@&=]*(/[-\w$.+!*'(),%;:@&=]*)*(\?[-\w$.+!*'(),%;:@&=]*)?)?

        // 所以， (http|https)://[-0-9a-zA-Z.]+(:\d+)?(/[-\w$.+!*'(),%;:@&=]*(/[-\w$.+!*'(),%;:@&=]*)*(\?[-\w$.+!*'(),%;:@&=]*)?)?
        // (http|https)://[-0-9a-zA-Z.]+    //主机名
        // (:\d+)?  //端口
        // ( //可选的路径和查询-开始
        // /[-\w$.+!*'(),%;:@&=]*  //第一层路径
        // (/[-\w$.+!*'(),%;:@&=]*)*    //可选的其他层路径
        // (\?[-\w$.+!*'(),%;:@&=]*)?   //可选的查询字符串
        // )? ////可选的路径和查询-结束
        Pattern p = Pattern.compile("(http|https)://[-0-9a-zA-Z.]+(:\\d+)?(/[-\\w$.+!*'(),%;:@&=]*(/[-\\w$.+!*'(),%;:@&=]*)*(\\?[-\\w$.+!*'(),%;:@&=]*)?)?");
        Matcher m = p.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }
    @Test
    public void _9Email地址(){
        String example = "5123234214@qq.com";
        // ([0-9a-zA-Z][-0-9a-zA-Z]{0,62}\.)+[a-zA-Z]{2,3}
        Pattern GENERAL_EMAIL_PATTERN = Pattern.compile(
                "[0-9a-zA-Z][-._0-9a-zA-Z]{0,63}" // 用户名
                + "@"
                + "([0-9a-zA-Z][-0-9a-zA-Z]{0,62}\\.)+" // 域名部分
                + "[a-zA-Z]{2,3}"); // 顶级域名
        Matcher m = GENERAL_EMAIL_PATTERN.matcher(example);
        while (m.find()) {
            System.out.println(m.group());
        }
    }
    @Test
    public void _10中文字符(){
        // 中文字符的Unicode编号一般位于\u4e00-\u9fff之间
        // [\u4e00-\u9fff]
        Pattern CHINESE_PATTERN = Pattern.compile(
                "[\\u4e00-\\u9fff]");
    }
}
